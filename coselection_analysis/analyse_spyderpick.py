import pandas as pd
import argparse
import numpy as np

def generate_gene_id(unsplit_id):
    name = unsplit_id.split("SAM")[1].split("_")[0].split(".")[0]
    split_gene = unsplit_id.split("_")
    gene_id = split_gene[-1]
    contig_id = split_gene[-2][-5:]

    gene_name = name + "_" + contig_id + "_" + gene_id

    return gene_name

def parse_args():
    parser = argparse.ArgumentParser(description="Identify outlier genes from Spyderpick analysis.")
    parser.add_argument("--spyderpick-edges", type=str, required=True, help="Path to Spyderpick edges file.")
    parser.add_argument("--pa-matrix", type=str, required=True, help="Path to pa matrix generated by generate_pa_matrix.py.")
    parser.add_argument("--annotations", type=str, default=None, help="Path to file generated by annotate_tokens.py (Optional).")
    parser.add_argument("--min-MI", type=float, default=None, help="MI values equal to or below this are discounted. Default is undefined.")
    parser.add_argument("--direct-only", default=False, action="store_true", help="Indirect MI values are discounted.")
    parser.add_argument("--outpref", default="output", help="Output prefix")

    args = parser.parse_args()

    return args

def main():
    options = parse_args()
    spyderpick_edges = options.spyderpick_edges
    pa_matrix = options.pa_matrix
    annotations = options.annotations
    outpref = options.outpref
    min_MI = options.min_MI
    direct_only = options.direct_only

    print("Generating gene index...")
    # determine if reversed
    reverse = False
    with open(pa_matrix, "r") as input:
        header = input.readline().split(",")
        if header[0] == "genome":
            reverse = True
    
    # reverse is more computational efficient, although input is unconventional
    if reverse:
        with open(pa_matrix, "r") as input:
            header = input.readline().rstrip().split(",")
            gene_index = header[1:]
    else:
        df = pd.read_csv(infile, sep=",")
        df = df.set_index(df.columns[0])

        gene_index = df.columns[0].tolist()

    print(f"Number of genes: {len(gene_index)}")

    # first pass through file, determine distribution of MI values
    print("Determining MI cutoff...")
    MI_list = []
    with open(spyderpick_edges, "r") as f:
        for line in f:
            pos1, pos2, genome_distance, ARACNE, MI = line.strip().split(" ")

            # ignore indirect links
            if direct_only:
                if ARACNE != "1":
                    continue

            MI = float(MI)

            if min_MI != None:
                if MI > min_MI:
                    MI_list.append(MI)
                else:
                    break # ordered so reached end
            else:
                MI_list.append(MI)

    Q1 = np.percentile(MI_list, 25)
    Q3 = np.percentile(MI_list, 75)

    outlier_threshold = Q3 + (1.5 * (Q3 - Q1))
    extreme_outlier_threshold = Q3 + (3.0 * (Q3 - Q1))

    print(f"outlier_threshold: {outlier_threshold}")
    print(f"extreme_outlier_threshold: {extreme_outlier_threshold}")

    annotation_dict = {}
    overall_header = "Gene1\tGene2\tDistance\Direct\tMI\n"
    if annotations != None:
        print("Reading annotations...")
        # read in annotations
        with open(annotations, "r") as f:
            # get column names
            header = f.readline().rstrip().split("\t")[2:]

            #print(header)
            for line in f:
                split_line = line.rstrip().split("\t")
                token = split_line[1]
            
                annotation_dict[token] = split_line[2:]

        overall_header = "Gene1\tGene2\tDistance\tDirect\tMI\tGene1_" + "\t".join(header) + "\tGene2_" + "\t".join(header) + "\n"

        annotation_placeholder = ["NA"] * len(header)

    # second pass, determine outliers
    print("Identifying outliers...")
    with open(spyderpick_edges, "r") as f, open(outpref + "_direct_outliers.tsv", "w") as o1, open(outpref + "_indirect_outliers.tsv", "w") as o2, open(outpref + "_direct_extreme_outliers.tsv", "w") as o3, open(outpref + "_indirect_extreme_outliers.tsv", "w") as o4:
        o1.write(overall_header)
        o2.write(overall_header)
        o3.write(overall_header)
        o4.write(overall_header)
        
        for line in f:
            pos1, pos2, genome_distance, ARACNE, MI = line.strip().split(" ")

            # 0-index
            pos1 = int(pos1) - 1
            pos2 = int(pos2) - 1

            gene1 = gene_index[pos1]
            gene2 = gene_index[pos2]
            direct = True if ARACNE == "1" else False
            MI = float(MI)
            
            # determine if gone too far, as MI is ordered
            if MI < outlier_threshold:
                break
            else: # add to respective list
                if annotations != None:

                    # if annotation not present, is replacement of rare gene
                    gene1_annotation = annotation_placeholder
                    gene2_annotation = annotation_placeholder
                    
                    if gene1 in annotation_dict:
                        gene1_annotation = annotation_dict[gene1]
                    if gene2 in annotation_dict:
                        gene2_annotation = annotation_dict[gene2]

                    gene1_annotation = "\t".join(gene1_annotation)
                    gene2_annotation = "\t".join(gene2_annotation)

                    gene_entry = f"{gene1}\t{gene2}\t{genome_distance}\t{ARACNE}\t{str(MI)}\t{gene1_annotation}\t{gene2_annotation}\n"
                else:
                    gene_entry = f"{gene1}\t{gene2}\t{genome_distance}\t{ARACNE}\t{str(MI)}\n"

                if MI >= extreme_outlier_threshold:
                    if direct:
                        o3.write(gene_entry)
                    else:
                        o4.write(gene_entry)
                else:
                    if direct:
                        o1.write(gene_entry)
                    else:
                        o2.write(gene_entry)


if __name__ == "__main__":
    main()
